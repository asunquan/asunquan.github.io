<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Swift 中的指针使用</title>
  <meta name="description" content="Apple 期望在 Swift 中指针能够尽量减少登场几率，因此在 Swift 中指针被映射为了一个泛型类型，并且还比较抽象。这在一定程度上造成了在 Swift 中指针使用的困难，特别是对那些并不熟悉指针，也没有多少指针操作经验的开发者 (包括我自己也是) 来说，在 Swift 中使用指针确实是一个挑战。在这篇文...">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Swift 中的指针使用">
  <meta name="twitter:description" content="Apple 期望在 Swift 中指针能够尽量减少登场几率，因此在 Swift 中指针被映射为了一个泛型类型，并且还比较抽象。这在一定程度上造成了在 Swift 中指针使用的困难，特别是对那些并不熟悉指针，也没有多少指针操作经验的开发者 (包括我自己也是) 来说，在 Swift 中使用指针确实是一个挑战。在这篇文...">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="Swift 中的指针使用">
  <meta property="og:description" content="Apple 期望在 Swift 中指针能够尽量减少登场几率，因此在 Swift 中指针被映射为了一个泛型类型，并且还比较抽象。这在一定程度上造成了在 Swift 中指针使用的困难，特别是对那些并不熟悉指针，也没有多少指针操作经验的开发者 (包括我自己也是) 来说，在 Swift 中使用指针确实是一个挑战。在这篇文...">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://onevcat.com/2015/01/swift-pointer/">
  <link rel="alternate" type="application/rss+xml" title="Asunquan" href="http://onevcat.com/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Asunquan 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Asunquan logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Asunquan" class="blog-button">Asunquan</a></h1>

        
        <span class="panel-cover__subtitle panel-subtitle">不忘初心 不止于行</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨，我是王巍 (@onevcat)，一名来自中国的 iOS / Unity 开发者。现居日本，就职于 LINE。正在修行，探求创意之源。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        <p class="panel-cover__description"><a href="https://objccn.io/products/" target="_blank">ObjC 中国与 objc.io 合作最新作品《函数式 Swift》,《Core Data》及《Swift 进阶》已经发布</a>，<a href="https://boxueio.com">泊学网正在开展订阅赠书活动，也欢迎前往了解</a></p>
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="http://project.onevcat.com" target="_blank" title="我的项目">项目</a></li>
                
                  <li class="navigation__item"><a href="http://about.onevcat.com/" target="_blank" title="了解更多关于我">关于</a></li>
                
                  <li class="navigation__item"><a href="//store.objccn.io/subscribe" target="_blank" title="邮件订阅本站">订阅</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/onevcat" title="@onevcat 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/onevcat" title="@onevcat 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  
  <!-- Twitter -->
  <li class="navigation__item">
    <a href="http://twitter.com/onevcat" title="@onevcat" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>
  

  
  <!-- Google Plus -->
  <li class="navigation__item">
    <a href="https://plus.google.com/107108267983477358170" rel="author" title="Google+" target="_blank">
      <i class='social fa fa-google-plus-square'></i>
      <span class="label">Google Plus</span>
    </a>
  </li>
  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:onev@onevcat.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-slate"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2015-01-19 11:38:21 +0800" itemprop="datePublished" class="post-meta__date date">2015-01-19</time> &#8226; <span class="post-meta__tags tags">能工巧匠集</span>
    </div>
    <h1 class="post-title">Swift 中的指针使用</h1>
  </header>

  <section class="post">
    <p>Apple 期望在 Swift 中指针能够尽量减少登场几率，因此在 Swift 中指针被映射为了一个泛型类型，并且还比较抽象。这在一定程度上造成了在 Swift 中指针使用的困难，特别是对那些并不熟悉指针，也没有多少指针操作经验的开发者 (包括我自己也是) 来说，在 Swift 中使用指针确实是一个挑战。在这篇文章里，我希望能从最基本的使用开始，总结一下在 Swift 中使用指针的一些常见方式和场景。这篇文章假定你至少知道指针是什么，如果对指针本身的概念不太清楚的话，可以先看看这篇<a href="http://denniskubes.com/2012/08/16/the-5-minute-guide-to-c-pointers/">五分钟 C 指针教程</a> (或者它的<a href="http://blog.jobbole.com/25409/">中文版本</a>)，应该会很有帮助。</p>

<h2>初步</h2>

<p>在 Swift 中，指针都使用一个特殊的类型来表示，那就是 <code>UnsafePointer&lt;T&gt;</code>。遵循了 Cocoa 的一贯不可变原则，<code>UnsafePointer&lt;T&gt;</code> 也是不可变的。当然对应地，它还有一个可变变体，<code>UnsafeMutablePointer&lt;T&gt;</code>。绝大部分时间里，C 中的指针都会被以这两种类型引入到 Swift 中：C 中 const 修饰的指针对应 <code>UnsafePointer</code> (最常见的应该就是 C 字符串的 <code>const char *</code> 了)，而其他可变的指针则对应 <code>UnsafeMutablePointer</code>。除此之外，Swift 中存在表示一组连续数据指针的 <code>UnsafeBufferPointer&lt;T&gt;</code>，表示非完整结构的不透明指针 <code>COpaquePointer</code> 等等。另外你可能已经注意到了，能够确定指向内容的指针类型都是泛型的 struct，我们可以通过这个泛型来对指针指向的类型进行约束以提供一定安全性。</p>

<p>对于一个 <code>UnsafePointer&lt;T&gt;</code> 类型，我们可以通过 <code>memory</code> 属性对其进行取值，如果这个指针是可变的 <code>UnsafeMutablePointer&lt;T&gt;</code> 类型，我们还可以通过 <code>memory</code> 对它进行赋值。比如我们想要写一个利用指针直接操作内存的计数器的话，可以这么做：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">func incrementor(ptr: UnsafeMutablePointer&lt;Int&gt;) {
    ptr.memory += 1
}

var a = 10
incrementor(&amp;a)

a  // 11
</code></pre></figure>
<p>这里和 C 的指针使用类似，我们通过在变量名前面加上 <code>&amp;</code> 符号就可以将指向这个变量的指针传递到接受指针作为参数的方法中去。在上面的 <code>incrementor</code> 中我们通过直接操作 <code>memory</code> 属性改变了指针指向的内容。</p>

<p>与这种做法类似的是使用 Swift 的 <code>inout</code> 关键字。我们在将变量传入 <code>inout</code> 参数的函数时，同样也使用 <code>&amp;</code> 符号表示地址。不过区别是在函数体内部我们不需要处理指针类型，而是可以对参数直接进行操作。</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">func incrementor1(inout num: Int) {
    num += 1
}

var b = 10
incrementor1(&amp;b)

b  // 11
</code></pre></figure>
<p>虽然 <code>&amp;</code> 在参数传递时表示的意义和 C 中一样，是某个“变量的地址”，但是在 Swift 中我们没有办法直接通过这个符号获取一个 <code>UnsafePointer</code> 的实例。需要注意这一点和 C 有所不同：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">// 无法编译
let a = 100
let b = &amp;a
</code></pre></figure>
<h2>指针初始化和内存管理</h2>

<p>在 Swift 中不能直接取到现有对象的地址，我们还是可以创建新的 <code>UnsafeMutablePointer</code> 对象。与 Swift 中其他对象的自动内存管理不同，对于指针的管理，是需要我们手动进行内存的申请和释放的。一个 <code>UnsafeMutablePointer</code> 的内存有三种可能状态：</p>

<ul>
<li>内存没有被分配，这意味着这是一个 null 指针，或者是之前已经释放过</li>
<li>内存进行了分配，但是值还没有被初始化</li>
<li>内存进行了分配，并且值已经被初始化</li>
</ul>

<p>其中只有第三种状态下的指针是可以保证正常使用的。<code>UnsafeMutablePointer</code> 的初始化方法 (<code>init</code>) 完成的都是从其他类型转换到 <code>UnsafeMutablePointer</code> 的工作。我们如果想要新建一个指针，需要做的是使用 <code>alloc:</code> 这个类方法。该方法接受一个 <code>num: Int</code> 作为参数，将向系统申请 <code>num</code> 个数的对应泛型类型的内存。下面的代码申请了一个 <code>Int</code> 大小的内存，并返回指向这块内存的指针：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">var intPtr = UnsafeMutablePointer&lt;Int&gt;.alloc(1)
// &quot;UnsafeMutablePointer(0x7FD3A8E00060)&quot;
</code></pre></figure>
<p>接下来应该做的是对这个指针的内容进行初始化，我们可以使用 <code>initialize:</code> 方法来完成初始化：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">intPtr.initialize(10)
// intPtr.memory 为 10
</code></pre></figure>
<p>在完成初始化后，我们就可以通过 <code>memory</code> 来操作指针指向的内存值了。</p>

<p>在使用之后，我们最好尽快释放指针指向的内容和指针本身。与 <code>initialize:</code> 配对使用的 <code>destroy</code> 用来销毁指针指向的对象，而与 <code>alloc:</code> 对应的 <code>dealloc:</code> 用来释放之前申请的内存。它们都应该被配对使用：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">intPtr.destroy()
intPtr.dealloc(1)
intPtr = nil
</code></pre></figure>
<blockquote>
<p>注意其实在这里对于 <code>Int</code> 这样的在 C 中映射为 int 的 “平凡值” 来说，<code>destroy</code> 并不是必要的，因为这些值被分配在常量段上。但是对于像类的对象或者结构体实例来说，如果不保证初始化和摧毁配对的话，是会出现内存泄露的。所以没有特殊考虑的话，不论内存中到底是什么，保证 <code>initialize:</code> 和 <code>destroy</code> 配对会是一个好习惯。</p>
</blockquote>

<h2>指向数组的指针</h2>

<p>在 Swift 中将一个数组作为参数传递到 C API 时，Swift 已经帮助我们完成了转换，这在 Apple 的<a href="https://developer.apple.com/swift/blog/?id=6">官方博客</a>中有个很好的例子：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">import Accelerate

let a: [Float] = [1, 2, 3, 4]
let b: [Float] = [0.5, 0.25, 0.125, 0.0625]
var result: [Float] = [0, 0, 0, 0]

vDSP_vadd(a, 1, b, 1, &amp;result, 1, 4)

// result now contains [1.5, 2.25, 3.125, 4.0625]
</code></pre></figure>
<p>对于一般的接受 const 数组的 C API，其要求的类型为 <code>UnsafePointer</code>，而非 const 的数组则对应 <code>UnsafeMutablePointer</code>。使用时，对于 const 的参数，我们直接将 Swift 数组传入 (上例中的 <code>a</code> 和 <code>b</code>)；而对于可变的数组，在前面加上 <code>&amp;</code> 后传入即可 (上例中的 <code>result</code>)。</p>

<p>对于传参，Swift 进行了简化，使用起来非常方便。但是如果我们想要使用指针来像之前用 <code>memory</code> 的方式直接操作数组的话，就需要借助一个特殊的类型：<code>UnsafeMutableBufferPointer</code>。Buffer Pointer 是一段连续的内存的指针，通常用来表达像是数组或者字典这样的集合类型。</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">var array = [1, 2, 3, 4, 5]
var arrayPtr = UnsafeMutableBufferPointer&lt;Int&gt;(start: &amp;array, count: array.count)
// baseAddress 是第一个元素的指针
var basePtr = arrayPtr.baseAddress as UnsafeMutablePointer&lt;Int&gt;

basePtr.memory // 1
basePtr.memory = 10
basePtr.memory // 10

//下一个元素
var nextPtr = basePtr.successor()
nextPtr.memory // 2
</code></pre></figure>
<h2>指针操作和转换</h2>

<h3>withUnsafePointer</h3>

<p>上面我们说过，在 Swift 中不能像 C 里那样使用 <code>&amp;</code> 符号直接获取地址来进行操作。如果我们想对某个变量进行指针操作，我们可以借助 <code>withUnsafePointer</code> 这个辅助方法。这个方法接受两个参数，第一个是 <code>inout</code> 的任意类型，第二个是一个闭包。Swift 会将第一个输入转换为指针，然后将这个转换后的 <code>Unsafe</code> 的指针作为参数，去调用闭包。使用起来大概是这个样子：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">var test = 10
test = withUnsafeMutablePointer(&amp;test, { (ptr: UnsafeMutablePointer&lt;Int&gt;) -&gt; Int in
    ptr.memory += 1
    return ptr.memory
})

test // 11
</code></pre></figure>
<p>这里其实我们做了和文章一开始的 <code>incrementor</code> 相同的事情，区别在于不需要通过方法的调用来将值转换为指针。这么做的好处对于那些只会执行一次的指针操作来说是显而易见的，可以将“我们就是想对这个指针做点事儿”这个意图表达得更加清晰明确。</p>

<h3>unsafeBitCast</h3>

<p><code>unsafeBitCast</code> 是非常危险的操作，它会将一个指针指向的内存强制按位转换为目标的类型。因为这种转换是在 Swift 的类型管理之外进行的，因此编译器无法确保得到的类型是否确实正确，你必须明确地知道你在做什么。比如：</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">let arr = NSArray(object: &quot;meow&quot;)
let str = unsafeBitCast(CFArrayGetValueAtIndex(arr, 0), CFString.self)
str // “meow”
</code></pre></figure>
<p>因为 <code>NSArray</code> 是可以存放任意 <code>NSObject</code> 对象的，当我们在使用 <code>CFArrayGetValueAtIndex</code> 从中取值的时候，得到的结果将是一个 <code>UnsafePointer&lt;Void&gt;</code>。由于我们很明白其中存放的是 <code>String</code> 对象，因此可以直接将其强制转换为 <code>CFString</code>。</p>

<p>关于 <code>unsafeBitCast</code> 一种更常见的使用场景是不同类型的指针之间进行转换。因为指针本身所占用的的大小是一定的，所以指针的类型进行转换是不会出什么致命问题的。这在与一些 C API 协作时会很常见。比如有很多 C API 要求的输入是 <code>void *</code>，对应到 Swift 中为 <code>UnsafePointer&lt;Void&gt;</code>。我们可以通过下面这样的方式将任意指针转换为 UnsafePointer<Void>。</p>
<figure class="highlight"><pre><code class="language-text" data-lang="text">var count = 100
var voidPtr = withUnsafePointer(&amp;count, { (a: UnsafePointer&lt;Int&gt;) -&gt; UnsafePointer&lt;Void&gt; in
    return unsafeBitCast(a, UnsafePointer&lt;Void&gt;.self)
})
// voidPtr 是 UnsafePointer&lt;Void&gt;。相当于 C 中的 void *

// 转换回 UnsafePointer&lt;Int&gt;
var intPtr = unsafeBitCast(voidPtr, UnsafePointer&lt;Int&gt;.self)
intPtr.memory //100
</code></pre></figure>
<h2>总结</h2>

<p>Swift 从设计上来说就是以安全作为重要原则的，虽然可能有些啰嗦，但是还是要重申在 Swift 中直接使用和操作指针应该作为最后的手段，它们始终是无法确保安全的。从传统的 C 代码和与之无缝配合的 Objective-C 代码迁移到 Swift 并不是一件小工程，我们的代码库肯定会时不时出现一些和 C 协作的地方。我们当然可以选择使用 Swift 重写部分陈旧代码，但是对于像是安全或者性能至关重要的部分，我们可能除了继续使用 C API 以外别无选择。如果我们想要继续使用那些 API 的话，了解一些基本的 Swift 指针操作和使用的知识会很有帮助。</p>

<p>对于新的代码，尽量避免使用 <code>Unsafe</code> 开头的类型，意味着可以避免很多不必要的麻烦。Swift 给开发者带来的最大好处是可以让我们用更加先进的编程思想，进行更快和更专注的开发。只有在尊重这种思想的前提下，我们才能更好地享受这门新语言带来的种种优势。显然，这种思想是不包括到处使用 <code>UnsafePointer</code> 的 :)</p>

  </section>
</article>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- OneV's Den -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3324997515191619"
     data-ad-slot="9170309685"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2015/03/cross-platform/" title="link to 跨平台开发时代的 (再次) 到来？">跨平台开发时代的 (再次) 到来？</a></h2>
       <p class="excerpt">这篇文章主要想谈谈最近又刮起的移动开发跨平台之风，并着重介绍和对比一下像是 Xamarin，NativeScript 和 React Native 之类的东西。不会有特别深入的技术讨论，大家可以当作一篇科普类的文章来看。故事的开始“一次编码，处处运行” 永远是程序员们的理想乡。二十年前 Java 正是举着这面大旗登场，击败了众多竞争对手。但是时至今日，事实已经证明了 Java 笨重的体型和缓慢的发展显然已经很难再抓住这个时代快速跃动的脚步。在新时代的移动大潮下，一个应用想要取胜，完美的使用...&hellip;</p>
       <div class="post-list__meta"><time datetime="2015-03-27 17:56:08 +0800" class="post-list__meta--date date">2015-03-27</time> &#8226; <span class="post-list__meta--tags tags">能工巧匠集</span><a class="btn-border-small" href=/2015/03/cross-platform/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2014/11/watch-kit/" title="link to Apple WatchKit 初探">Apple WatchKit 初探</a></h2>
       <p class="excerpt">随着今天凌晨 Apple 发布了第一版的 Watch Kit 的 API，对于开发者来说，这款新设备的一些更详细的信息也算是逐渐浮出水面。可以说第一版的 WatchKit 开放的功能总体还是令人满意的。Apple 在承诺逐渐开放的方向上继续前进。本来在 WWDC 之后预期 Today Widget 会是各类新颖 app 的舞台以及对 iOS 功能的极大扩展，但是随着像 Launcher 和 PCalc 这些创意型的 Today Widget 接连被下架事件，让开发者也不得不下调对 Watc...&hellip;</p>
       <div class="post-list__meta"><time datetime="2014-11-19 16:40:22 +0800" class="post-list__meta--date date">2014-11-19</time> &#8226; <span class="post-list__meta--tags tags">能工巧匠集</span><a class="btn-border-small" href=/2014/11/watch-kit/>继续阅读</a></div>
   </div>
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://onevcat.com/2015/01/swift-pointer/";
        this.page.identifier = "/2015/01/swift-pointer/";
    };

    var disqus_shortname = 'onevcat';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2016-11-08 生成，感谢 <a href="https://www.digitalocean.com/?refcode=30ed2d146762">Digital Ocean</a> 为本站提供稳定的 VPS 服务</span>
        <span class="footer__copyright">本站由 <a href="http://onev.cat">@onevcat</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2016</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-25719337-1', 'onevcat.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
